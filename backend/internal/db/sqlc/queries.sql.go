// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getGuitarBySlug = `-- name: GetGuitarBySlug :one
SELECT
  guitar.id,
  guitar.slug,
  guitar.name,
  guitar.model,
  guitar.type,
  guitar.year,
  guitar.description,
  brand.name AS brand_name
FROM guitar
JOIN brand ON brand.id = guitar.brand_id
WHERE guitar.slug = $1
`

type GetGuitarBySlugRow struct {
	ID          string
	Slug        string
	Name        string
	Model       string
	Type        string
	Year        pgtype.Int4
	Description pgtype.Text
	BrandName   string
}

func (q *Queries) GetGuitarBySlug(ctx context.Context, slug string) (GetGuitarBySlugRow, error) {
	row := q.db.QueryRow(ctx, getGuitarBySlug, slug)
	var i GetGuitarBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Model,
		&i.Type,
		&i.Year,
		&i.Description,
		&i.BrandName,
	)
	return i, err
}

const getGuitarMedia = `-- name: GetGuitarMedia :many
SELECT
  kind,
  url
FROM guitar_media
WHERE guitar_id = $1
ORDER BY sort_order ASC
`

type GetGuitarMediaRow struct {
	Kind string
	Url  string
}

func (q *Queries) GetGuitarMedia(ctx context.Context, guitarID string) ([]GetGuitarMediaRow, error) {
	rows, err := q.db.Query(ctx, getGuitarMedia, guitarID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGuitarMediaRow
	for rows.Next() {
		var i GetGuitarMediaRow
		if err := rows.Scan(&i.Kind, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGuitarSpecs = `-- name: GetGuitarSpecs :many
SELECT
  spec.code,
  COALESCE(
    guitar_spec_value.value_text,
    guitar_spec_value.value_number::text,
    guitar_spec_value.value_bool::text,
    spec_option.value,
    ''
  ) AS value
FROM guitar_spec_value
JOIN spec ON spec.id = guitar_spec_value.spec_id
LEFT JOIN spec_option ON spec_option.id = guitar_spec_value.value_option_id
WHERE guitar_spec_value.guitar_id = $1
ORDER BY spec.code ASC
`

type GetGuitarSpecsRow struct {
	Code  string
	Value string
}

func (q *Queries) GetGuitarSpecs(ctx context.Context, guitarID string) ([]GetGuitarSpecsRow, error) {
	rows, err := q.db.Query(ctx, getGuitarSpecs, guitarID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGuitarSpecsRow
	for rows.Next() {
		var i GetGuitarSpecsRow
		if err := rows.Scan(&i.Code, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBrand = `-- name: InsertBrand :exec
INSERT INTO brand (id, name)
VALUES ($1, $2)
`

type InsertBrandParams struct {
	ID   string
	Name string
}

func (q *Queries) InsertBrand(ctx context.Context, arg InsertBrandParams) error {
	_, err := q.db.Exec(ctx, insertBrand, arg.ID, arg.Name)
	return err
}

const insertGuitar = `-- name: InsertGuitar :exec
INSERT INTO guitar (id, slug, name, brand_id, model, type, year, description, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertGuitarParams struct {
	ID          string
	Slug        string
	Name        string
	BrandID     string
	Model       string
	Type        string
	Year        pgtype.Int4
	Description pgtype.Text
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) InsertGuitar(ctx context.Context, arg InsertGuitarParams) error {
	_, err := q.db.Exec(ctx, insertGuitar,
		arg.ID,
		arg.Slug,
		arg.Name,
		arg.BrandID,
		arg.Model,
		arg.Type,
		arg.Year,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const insertGuitarMedia = `-- name: InsertGuitarMedia :exec
INSERT INTO guitar_media (id, guitar_id, kind, url, sort_order)
VALUES ($1, $2, $3, $4, $5)
`

type InsertGuitarMediaParams struct {
	ID        string
	GuitarID  string
	Kind      string
	Url       string
	SortOrder int32
}

func (q *Queries) InsertGuitarMedia(ctx context.Context, arg InsertGuitarMediaParams) error {
	_, err := q.db.Exec(ctx, insertGuitarMedia,
		arg.ID,
		arg.GuitarID,
		arg.Kind,
		arg.Url,
		arg.SortOrder,
	)
	return err
}

const insertGuitarSpecValue = `-- name: InsertGuitarSpecValue :exec
INSERT INTO guitar_spec_value (guitar_id, spec_id, value_text, value_number, value_bool, value_option_id, source)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertGuitarSpecValueParams struct {
	GuitarID      string
	SpecID        string
	ValueText     pgtype.Text
	ValueNumber   pgtype.Numeric
	ValueBool     pgtype.Bool
	ValueOptionID pgtype.UUID
	Source        NullSpecSource
}

func (q *Queries) InsertGuitarSpecValue(ctx context.Context, arg InsertGuitarSpecValueParams) error {
	_, err := q.db.Exec(ctx, insertGuitarSpecValue,
		arg.GuitarID,
		arg.SpecID,
		arg.ValueText,
		arg.ValueNumber,
		arg.ValueBool,
		arg.ValueOptionID,
		arg.Source,
	)
	return err
}

const insertSpec = `-- name: InsertSpec :exec
INSERT INTO spec (id, code, label, value_type, unit, filterable, searchable, guitar_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertSpecParams struct {
	ID         string
	Code       string
	Label      string
	ValueType  string
	Unit       pgtype.Text
	Filterable bool
	Searchable bool
	GuitarType NullGuitarType
}

func (q *Queries) InsertSpec(ctx context.Context, arg InsertSpecParams) error {
	_, err := q.db.Exec(ctx, insertSpec,
		arg.ID,
		arg.Code,
		arg.Label,
		arg.ValueType,
		arg.Unit,
		arg.Filterable,
		arg.Searchable,
		arg.GuitarType,
	)
	return err
}

const insertSpecOption = `-- name: InsertSpecOption :exec
INSERT INTO spec_option (id, spec_id, value, sort_order)
VALUES ($1, $2, $3, $4)
`

type InsertSpecOptionParams struct {
	ID        string
	SpecID    string
	Value     string
	SortOrder int32
}

func (q *Queries) InsertSpecOption(ctx context.Context, arg InsertSpecOptionParams) error {
	_, err := q.db.Exec(ctx, insertSpecOption,
		arg.ID,
		arg.SpecID,
		arg.Value,
		arg.SortOrder,
	)
	return err
}

const listGuitars = `-- name: ListGuitars :many
SELECT
  guitar.id,
  guitar.slug,
  guitar.name,
  guitar.model,
  guitar.type,
  guitar.year,
  brand.name AS brand_name,
  COALESCE(
    (
      SELECT url
      FROM guitar_media
      WHERE guitar_media.guitar_id = guitar.id
        AND guitar_media.kind = 'image'
      ORDER BY sort_order ASC
      LIMIT 1
    ),
    ''
  ) AS thumbnail_url
FROM guitar
JOIN brand ON brand.id = guitar.brand_id
ORDER BY guitar.name ASC
`

type ListGuitarsRow struct {
	ID           string
	Slug         string
	Name         string
	Model        string
	Type         string
	Year         pgtype.Int4
	BrandName    string
	ThumbnailUrl interface{}
}

func (q *Queries) ListGuitars(ctx context.Context) ([]ListGuitarsRow, error) {
	rows, err := q.db.Query(ctx, listGuitars)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGuitarsRow
	for rows.Next() {
		var i ListGuitarsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Model,
			&i.Type,
			&i.Year,
			&i.BrandName,
			&i.ThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
